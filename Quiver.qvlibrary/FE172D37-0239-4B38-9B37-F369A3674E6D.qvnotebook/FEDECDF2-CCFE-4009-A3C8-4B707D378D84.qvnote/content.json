{
  "title": "Spring 依赖注入",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"margin: 0px 0px 5px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0); line-height: 1.7; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">每个基于应用程序的 java 都有几个对象，这些对象一起工作来呈现出终端用户所看到的工作的应用程序。当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能独立于其他 Java 类来增加这些类重用的可能性，并且在做单元测试时，测试独立于其他类的独立性。依赖注入（或有时称为布线）有助于把这些类粘合在一起，同时保持他们独立。</p>"
    },
    {
      "type": "text",
      "data": "<span style=\"color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">依赖关系（即 SpellChecker 类）通过</span><strong style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">类构造函数</strong><span style=\"color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">被注入到 TextEditor 类中</span>"
    },
    {
      "type": "text",
      "data": "<span style=\"color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">控制流通过依赖注入（DI）已经“反转”，因为你已经有效地委托依赖关系到一些外部系统。</span><div><span style=\"color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><div class=\"wkcontent\" style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-variant-ligatures: normal; background-color: rgb(255, 255, 255);\"><p style=\"margin: 0px 0px 5px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0); line-height: 1.7;\">依赖注入的第二种方法是通过 TextEditor 类的&nbsp;<strong style=\"margin: 0px; padding: 0px;\">Setter 方法</strong>，我们将创建 SpellChecker 实例，该实例将被用于调用 setter 方法来初始化 TextEditor 的属性。</p><p style=\"margin: 0px 0px 5px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0); line-height: 1.7;\">因此，DI 主要有两种变体和下面的两个子章将结合实例涵盖它们：</p><table class=\"table table-bordered  \" style=\"margin: 15px 0px; padding: 0px; width: 699px; table-layout: fixed;\"><tbody style=\"margin: 0px; padding: 0px;\"><tr style=\"margin: 0px; padding: 0px;\"><th class=\"fivepct\" style=\"margin: 0px; padding: 2px 4px; background-color: rgb(255, 255, 255); border-color: rgb(204, 204, 204);\">序号</th><th style=\"margin: 0px; padding: 2px 4px; background-color: rgb(255, 255, 255); border-color: rgb(204, 204, 204);\">依赖注入类型 &amp; 描述</th></tr><tr style=\"margin: 0px; padding: 0px;\"><td style=\"margin: 0px; padding: 2px 4px; min-width: 40px; height: 30px; border-color: rgb(204, 204, 204); vertical-align: top; box-sizing: border-box;\">1</td><td style=\"margin: 0px; padding: 2px 4px; min-width: 40px; height: 30px; border-color: rgb(204, 204, 204); vertical-align: top; box-sizing: border-box;\"><a href=\"https://www.w3cschool.cn/wkspring/t7n41mm7.html\" target=\"_blank\" style=\"margin: 0px; padding: 0px; color: rgb(144, 11, 9); outline: 0px; word-break: break-all;\">Constructor-based dependency injection</a><p style=\"margin: 0px 0px 5px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0); line-height: 1.7;\">当容器调用带有多个参数的构造函数类时，实现基于构造函数的 DI，每个代表在其他类中的一个依赖关系。</p></td></tr><tr style=\"margin: 0px; padding: 0px;\"><td style=\"margin: 0px; padding: 2px 4px; min-width: 40px; height: 30px; border-color: rgb(204, 204, 204); vertical-align: top; box-sizing: border-box;\">2</td><td style=\"margin: 0px; padding: 2px 4px; min-width: 40px; height: 30px; border-color: rgb(204, 204, 204); vertical-align: top; box-sizing: border-box;\"><a href=\"https://www.w3cschool.cn/wkspring/yqdx1mm5.html\" target=\"_blank\" style=\"margin: 0px; padding: 0px; color: rgb(144, 11, 9); outline: 0px; word-break: break-all;\">Setter-based dependency injection</a><p style=\"margin: 0px 0px 5px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0); line-height: 1.7;\">基于 setter 方法的 DI 是通过在调用无参数的构造函数或无参数的静态工厂方法实例化 bean 之后容器调用 beans 的 setter 方法来实现的。</p></td></tr></tbody></table><p style=\"margin: 0px 0px 5px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0); line-height: 1.7;\">你可以混合这两种方法，基于构造函数和基于 setter 方法的 DI，然而使用有强制性依存关系的构造函数和有可选依赖关系的 sette r是一个好的做法。</p><p style=\"margin: 0px 0px 5px; padding: 0px; word-wrap: break-word; color: rgb(0, 0, 0); line-height: 1.7;\">代码是 DI 原理的清洗机，当对象与它们的依赖关系被提供时，解耦效果更明显。对象不查找它的依赖关系，也不知道依赖关系的位置或类，而这一切都由 Spring 框架控制的。</p><div><br></div></div></span></div>"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}